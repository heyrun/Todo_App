{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","csrftoken","getCookie","state","todoList","activeItem","id","title","completed","editing","fetchTasks","bind","handleChange","handleSubmit","startEdit","startDelete","this","name","cookieValue","document","cookie","cookies","split","i","length","trim","substring","decodeURIComponent","fetch","then","response","json","data","setState","e","value","target","url","method","headers","body","JSON","stringify","catch","error","console","log","preventDefault","tasks","self","className","onSubmit","style","flex","onChange","type","map","task","index","key","onClick","taskComplete","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.2ddd8e80.chunk.js","sourcesContent":["import React from 'react';\n\nimport './App.css';\n\nclass App extends React.Component{\n\n\n  constructor(props){\n\n    super(props);\n\n    this.state={\n      todoList:[],\n      activeItem:{\n        id: null,\n        title: '',\n        completed: false,\n      },\n      editing: false,\n    }\n    this.fetchTasks = this.fetchTasks.bind(this)\n    this.handleChange = this.handleChange.bind(this)\n    this.handleSubmit = this.handleSubmit.bind(this)\n    this.getCookie = this.getCookie.bind(this)\n    this.startEdit =  this.startEdit.bind(this)\n    this.startDelete = this.startDelete.bind(this)\n  };\n  componentDidMount(){\n    this.fetchTasks()\n\n  }\n  getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\ncsrftoken = this.getCookie('csrftoken');\n  fetchTasks(){\n\n    fetch('http://localhost:8000/api/task-list/')\n    .then(response=> response.json())\n    .then(data=>\n      this.setState({\n        todoList: data\n      })\n      \n      \n      )\n\n  }\n  handleChange(e){\n    // var name = e.target.name\n    var value = e.target.value\n  \n  \n    this.setState({\n      activeItem:{\n\n        ...this.state.activeItem,\n      title: value\n\n\n      }\n      \n\n      \n    })\n\n   \n  }\n  startEdit(e){\n\n    this.setState({\n      activeItem: {\n        ...this.state.activeItem,\n        id: e.id,\n        title: e.title\n      },\n      editing: true\n\n    })\n\n\n  }\n  taskComplete(e){\n    \n    var url = `http://localhost:8000/api/task-update/${e.id}/` \n    e.completed = !e.completed\n\n\n   \n    fetch(url, {\n      method: 'POST',\n      headers: {\n          'Content-type': 'application/json',\n          'X-CSRFToken': this.csrftoken\n      },\n      body: JSON.stringify(e)}).then((response)=>{\n        this.fetchTasks()\n        this.setState({\n          activeItem:{\n            id: null,\n            title: '',\n            completed: false,\n          }\n        })\n      }).catch(function(error){ console.log(\"ERROR\", error)})\n   \n  }\n  startDelete(e){\n    var id =  e.id\n     \n    var url = `http://localhost:8000/api/task-delete/${id}/`\n\n   fetch(url, {\n    method: 'DELETE',\n    headers: {\n        'Content-type': 'application/json',\n        'X-CSRFToken': this.csrftoken\n    },\n   }).then((response)=>{\n      this.fetchTasks()\n      this.setState({\n        activeItem:{\n          id: null,\n          title: '',\n          completed: false,\n        }\n      })\n    }).catch(function(error){ console.log(\"ERROR\", error)\n   })\n  }\n\n  handleSubmit(e){\n \n    e.preventDefault();\n\n   if(!this.state.editing){\n\n        \n     var url = 'http://localhost:8000/api/task-create/'\n   }\n   else {\n      var id =  this.state.activeItem.id\n     \n      var url = `http://localhost:8000/api/task-update/${id}/`\n      this.setState({\n        editing: false\n      })  \n    }\n\n\n    \n    fetch(url, {\n      method: 'POST',\n      headers: {\n          'Content-type': 'application/json',\n          'X-CSRFToken': this.csrftoken\n      },\n      body: JSON.stringify(this.state.activeItem)}).then((response)=>{\n        this.fetchTasks()\n        this.setState({\n          activeItem:{\n            id: null,\n            title: '',\n            completed: false,\n          }\n        })\n      }).catch(function(error){ console.log(\"ERROR\", error)})\n   \n\n  }\n\n  render(){\n    var tasks =  this.state.todoList;\n    var self = this\n    return(\n\n\n      <div className=\"container\">\n        <h2>TO Do App</h2>\n        <div id=\"task-container\">\n          <div id=\"form-wrapper\">\n            <form onSubmit={this.handleSubmit}  id=\"form\">\n\n              <div className=\"flex-wrapper\">\n                <div style={{flex:6}}> \n                       <input  onChange={this.handleChange} name=\"title\" id=\"title\" className=\"form-control\" type=\"text\" value={this.state.activeItem.title}></input>\n                </div>\n                <div style={{flex:1}}>\n                  <button  name=\"\" id=\"submit\" className=\"btn btn-primary\" value=\"Submit\" >Submit</button>\n                </div>\n          \n              </div>\n            </form>\n          </div>\n          <div id=\"list-wrapper\">\n            {tasks.map((task, index)=>{\n              return(\n                <div key={index} className=\"task-wrapper flex-wrapper\">\n\n              <div style={{flex:7}} onClick={()=>self.taskComplete(task)}> {(task.completed)? <strike  >{task.title}</strike>: <span>{task.title}</span>}</div>\n                  <button className=\"btn btn-outline-info Edit\" onClick={()=>self.startEdit(task)}>\n                          Edit \n                  </button> \n                  <button className=\"btn btn-danger ml-1 Delete\" onClick={()=>self.startDelete(task)}>\n                          - \n                  </button>\n                  \n                  </div>\n\n              )\n            })}\n          </div>\n        </div>\n\n\n        \n      </div>\n    )\n  }\n\n\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}